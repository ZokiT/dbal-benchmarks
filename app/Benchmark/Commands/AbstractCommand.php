<?php

namespace App\Benchmark\Commands;

use App\Benchmark\Benchmark;
use Exception;
use Imagick;
use ImagickDraw;
use ImagickPixel;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Helper\Table;
use Symfony\Component\Console\Helper\TableSeparator;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Output\StreamOutput;
use Throwable;

abstract class AbstractCommand extends Command
{

    const ITERATIONS_OPTION     = 'numberOfIterations';
    const GENERATE_IMAGE_OPTION = 'image';


    const FONTS_FOLDER = './public/fonts/monospace.ttf';

    // TODO add option for charts results storing and showing the charts
    const CHARTS_FOLDER = './public/charts';

    // TODO split the whole const and methods for generating images in separate Classes
    const IMAGES_FOLDER = './public/images/';
    const IMAGES_EXTENSION = '.png';
    const IMAGES_TABLE_CHARACTER_WIDTH = 10;
    const IMAGES_TABLE_ROW_HEIGHT = 17;
    const IMAGES_TABLE_MARGINS = 20;
    const IMAGES_TABLE_PADDINGS = 10;

    private Benchmark $benchmark;

    public function __construct(Benchmark $benchmark, string $name = null)
    {
        $this->benchmark = $benchmark;
        parent::__construct($name);
        // TODO add command name for graph title
    }

    protected function configure(): void {
        $this
            ->addOption(self::ITERATIONS_OPTION, 'i',  InputArgument::OPTIONAL, 'number of iterations to perform the benchmarks')
            ->addOption(self::GENERATE_IMAGE_OPTION, null, InputArgument::OPTIONAL, 'export the result to image');
    }

    protected function outputResults(OutputInterface $output): void {

        //TODO store the result to local file for graph UI

        $this->prepareAndRenderTableResults($output);

        if ($this->getBenchmark()->getOutputToImage()) {

            if (!file_exists(self::IMAGES_FOLDER)){
                mkdir(self::IMAGES_FOLDER);
            }

            try {
                $this->generateImage($this->getOutputResultsAsString());
                $output->writeln("Result was generated in image");
            } catch (Throwable $throwable) {
                $output->writeln($throwable->getMessage());
            }
        }
    }

    public function execute(InputInterface $input, OutputInterface $output): int
    {
        $this->getBenchmark()->setIterations((int)$input->getOption(self::ITERATIONS_OPTION));
        $this->getBenchmark()->setOutputToImage((boolean)$input->getOption(self::GENERATE_IMAGE_OPTION));

        $this->getBenchmark()->run($output);
        $this->outputResults($output);

        return Command::SUCCESS;
    }

    public function getBenchmark(): Benchmark
    {
        return $this->benchmark;
    }

    private function prepareAndRenderTableResults(OutputInterface $output)
    {
        $table = new Table($output);
        $table->setHeaderTitle($this->getName());

        $rows = [];
        foreach ($array = $this->getBenchmark()->getResults() as $result) {
            $rows[] = $result;
            if ($result !== end($array)) {
                $rows[] = new TableSeparator();
            }
        }

        $table
            ->setHeaders($this->getBenchmark()::TABLE_HEADERS)
            ->setRows($rows)
        ;

        // Render the table to the StreamOutput
        $table->render();
    }

    /**
     * @throws Exception
     */
    private function generateImage(bool|string $tableString)
    {
        if (is_bool($tableString)) {
            throw new Exception('Unable to export the result to image');
        }

        $splitTableStringRows = explode("\n", $tableString);

        // Filter the table results generated by Symphony from ANSI formats and codes
        $filteredSplitTableStringRows = array_map(function (string $inputString) {
            return preg_replace('/\033\[[0-9;]*[mGK]/', '', $inputString);
        }, $splitTableStringRows);

        // Create a new Imagick instance
        $image = new Imagick();

        // Create an ImagickDraw object
        $draw = new ImagickDraw();

        // Set font properties
        $draw->setFont(self::FONTS_FOLDER);
        $draw->setFontSize(12);
        $draw->setFillColor(new ImagickPixel('black'));

        // Calculate total width and height for the image
        $totalWidth = strlen($filteredSplitTableStringRows[0]) * self::IMAGES_TABLE_CHARACTER_WIDTH;
        $totalHeight = count($filteredSplitTableStringRows) * self::IMAGES_TABLE_ROW_HEIGHT;

        // Set image dimensions based on calculated values
        $image->newImage($totalWidth + self::IMAGES_TABLE_MARGINS, $totalHeight + self::IMAGES_TABLE_MARGINS, new ImagickPixel('white'));

        // Set initial position
        $y = self::IMAGES_TABLE_PADDINGS;
        $x = self::IMAGES_TABLE_PADDINGS;

        // Set cell height
        $cellHeight = self::IMAGES_TABLE_ROW_HEIGHT;

        foreach ($filteredSplitTableStringRows as $row) {
            $this->drawText($image, $draw, $x, $y, $totalWidth, $cellHeight, $row);
            $y += $cellHeight;
        }

        // Save the image to a file
        $image->writeImage(self::IMAGES_FOLDER . $this->getName() . date('Ymd_His') . self::IMAGES_EXTENSION);

        // Free up memory
        $image->clear();
        $image->destroy();
    }

    private function drawText($image, $draw, $x, $y, $width, $height, $text)
    {
        $fontMetrics = $image->queryFontMetrics($draw, $text);
        $textX = $x + ($width - $fontMetrics['textWidth']) / 2;
        $textY = $y + ($height + $fontMetrics['textHeight']) / 2;

        $image->annotateImage($draw, $textX, $textY, 0, $text);
    }

    private function getOutputResultsAsString(): bool|string
    {
        // Create a StreamOutput to capture the output
        $stream = fopen('php://temp', 'w+');
        $streamOutput = new StreamOutput($stream);

        $this->prepareAndRenderTableResults($streamOutput);

        // Get the content of the StreamOutput and close the stream
        rewind($stream);
        $tableString = stream_get_contents($stream);
        fclose($stream);

        return $tableString;
    }
}